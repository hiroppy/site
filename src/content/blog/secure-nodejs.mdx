---
layout: ../../layouts/BlogLayout.astro
title: 簡単に導入できるNode.js のセキュリティ強化
date: 2025-07-08
description: SPA, SSR, PWAをどのように安全に作るかを解説します
image: /images/brands/nodejs.png
tags: node.js
---

import OG from "../../components/OG.astro";

今回は CLI オプションだけで導入できる Node.js のセキュリティ強化 をまとめます。
「動いたけど危険だった」コードを本番に送り込まないために、**CI〜本番まで同じフラグ** を徹底しましょう。

|  §  | テーマ                          | 重点フラグ                                    |
| :-: | :------------------------------ | :-------------------------------------------- |
|  1  | Injection Sinks (eval など)     | `--disallow-code-generation-from-strings`     |
|  2  | Monkey Patching                 | `--frozen-intrinsics`                         |
|  3  | Prototype Pollution             | `--disable-proto=throw`                       |
|  4  | Permission Model                | `--permission`                                |
|  5  | **Secure Heap**                 | `--secure-heap`                               |
|  6  | **Policy & Integrity Manifest** | `--experimental-policy`, `--policy-integrity` |

## Injection Sinks — コード実行の脆弱性を防ぐ

**eval**、**Function**、**WebAssembly.compile** などによる動的コード実行は、RCE（Remote Code Execution）攻撃の入り口となります。

### 攻撃例

```js
// クエリパラメータからの攻撃
// ?q=process.mainModule.require('fs').readFileSync('/etc/passwd','utf8')
eval(`db.find("${req.query.q}")`); // ← RCE

// テンプレートエンジンでの攻撃
new Function(`return ${userInput}`)();

// WebAssemblyを使った攻撃
WebAssembly.compile(maliciousBuffer);

// VM モジュールでの攻撃
const vm = require("vm");
vm.runInThisContext(userCode); // 同様に危険
```

### 防御方法

```sh
$ node --disallow-code-generation-from-strings index.mjs
```

このフラグにより、以下の API が無効化されます：

- `eval()`
- `new Function()`
- `WebAssembly.compile()`
- `WebAssembly.instantiate()`
- `vm.runInThisContext()` (一部制限)

### 実際の導入での注意点

**既存のライブラリが動的コード生成を使用している場合**、エラーが発生します：

```js
// これらのライブラリは要注意
const handlebars = require("handlebars"); // テンプレートコンパイル
const lodash = require("lodash"); // template関数
const jsonpath = require("jsonpath"); // 動的関数生成
const moment = require("moment"); // 一部のロケール処理
```

**代替案**：

- テンプレートエンジンは事前コンパイル版を使用
- CSP（Content Security Policy）ヘッダーでも `unsafe-eval` を禁止
- TypeScript使用時は `noImplicitEval` を有効化
- 静的解析ツール（ESLint）で `no-eval` ルールを強制

### 検証方法

```js
// 設定が有効かテスト
try {
  eval('console.log("test")');
  console.log("❌ eval is enabled");
} catch (e) {
  console.log("✅ eval is disabled");
}

try {
  new Function("return 42")();
  console.log("❌ Function constructor is enabled");
} catch (e) {
  console.log("✅ Function constructor is disabled");
}
```

## Monkey Patching — ビルトインオブジェクトの改ざんを防ぐ

依存ライブラリが `Array.prototype.push = …` を上書きすると、他ライブラリや Node.js コアの前提が崩壊します。

### 攻撃シナリオ

```js
// 悪意のあるライブラリやプロトタイプ汚染
Array.prototype.push = function (item) {
  // 全ての配列操作を監視・改ざん
  console.log("Intercepted:", item);
  if (item.includes("password")) {
    sendToAttacker(item);
  }
  return originalPush.call(this, item);
};

// 他のコードに影響
const users = [];
users.push({ username: "admin", password: "secret" }); // ← 情報漏洩

// JSON.parseの改ざん
const originalParse = JSON.parse;
JSON.parse = function (text) {
  const result = originalParse(text);
  // 機密情報を抜き取り
  if (result.token) {
    exfiltrateData(result.token);
  }
  return result;
};
```

### 防御方法

```sh
$ node --frozen-intrinsics app.mjs
```

**効果**：

- すべてのビルトイン (Object, Array, Date …) を再帰的に `Object.freeze()`
- 必要な polyfill は **`--require core-js`** などで「凍結前」にロード
- プロトタイプチェーン全体が不変になる
- グローバルオブジェクトも保護される

### 実装上の考慮点

**polyfill の導入順序が重要**：

```sh
# 正しい順序：polyfill → 凍結 → アプリケーション
node --require core-js/stable --frozen-intrinsics app.mjs

# babel-polyfill の場合
node --require @babel/polyfill --frozen-intrinsics app.mjs
```

**動作確認**：

```js
// 凍結後は例外が発生
try {
  Array.prototype.maliciousMethod = () => {};
} catch (e) {
  console.log("✅ Protected!", e.message); // TypeError: Cannot add property
}

try {
  Object.prototype.polluted = "value";
} catch (e) {
  console.log("✅ Object.prototype protected");
}

// 既存メソッドの上書きも不可
try {
  Array.prototype.push = () => {};
} catch (e) {
  console.log("✅ Array.prototype.push protected");
}
```

### 注意が必要なライブラリ

```js
// これらのライブラリはfrozen-intrinsicsと相性問題の可能性
require("core-js"); // polyfillライブラリ
require("babel-polyfill"); // Babel polyfill
require("zone.js"); // Angular依存
require("reflect-metadata"); // TypeScript decorators
```

## Prototype Pollution — プロトタイプ汚染攻撃を阻止

`__proto__` を使ったプロトタイプ汚染は、オブジェクトマージ処理で頻発する脆弱性です。

### 攻撃の仕組み

```js
// 危険なマージ処理
function merge(target, source) {
  for (const key in source) {
    if (typeof source[key] === "object") {
      target[key] = merge(target[key] || {}, source[key]);
    } else {
      target[key] = source[key];
    }
  }
  return target;
}

// 攻撃ペイロード
const malicious = {
  __proto__: {
    isAdmin: true,
    polluted: "value",
  },
};

merge({}, malicious);

// 全てのオブジェクトが汚染される
console.log({}.isAdmin); // true
console.log({}.polluted); // "value"

// 実際の攻撃例
const userInput = JSON.parse('{"__proto__": {"isAdmin": true}}');
merge(config, userInput);
// 以降、全てのオブジェクトがisAdmin: trueを持つ
```

### 防御方法

```sh
$ node --disable-proto=throw --frozen-intrinsics server.mjs
```

**効果**：

- `__proto__` 参照・代入時に即例外
- `Object.prototype.__proto__` アクセスを完全に禁止

### 安全なマージの実装

```js
// structuredClone を使用（Node.js 17+）
function safeMerge(target, source) {
  const cloned = structuredClone(source);
  return { ...target, ...cloned };
}

// ライブラリを使用
const merge = require("lodash.mergewith");
const result = merge(target, source, (objValue, srcValue) => {
  // カスタムマージロジック
  return Array.isArray(objValue) ? objValue.concat(srcValue) : undefined;
});

// 入力検証
const Ajv = require("ajv");
const ajv = new Ajv();
const schema = {
  type: "object",
  properties: {
    name: { type: "string" },
    age: { type: "number" },
  },
  additionalProperties: false, // __proto__ などを拒否
};

if (!ajv.validate(schema, userInput)) {
  throw new Error("Invalid input");
}
```

### 検証方法

```js
// プロトタイプ汚染の検出
function detectPrototypePollution() {
  const testObject = {};
  try {
    testObject.__proto__.polluted = "test";
    console.log("❌ Prototype pollution possible");
  } catch (e) {
    console.log("✅ Prototype pollution blocked");
  }
}

// 既存の汚染チェック
function checkExistingPollution() {
  const clean = {};
  const suspicious = ["isAdmin", "isOwner", "polluted", "constructor"];

  for (const prop of suspicious) {
    if (prop in clean) {
      console.warn(`⚠️ Possible pollution detected: ${prop}`);
    }
  }
}
```

## Permission Model

ファイル＆サブプロセスをホワイトリスト化

```sh
node --permission \
     --allow-fs-read=/var/data \
     --allow-child-process \
     api.mjs
```

- デフォルトで **全権限拒否**、個別に `--allow-*` で解放
- v21.6.0 以降は相対パス許可が強化

---

## Secure Heap

ヒープダンプや隣接メモリ破壊から **秘密鍵流出 (CWE‑284)** を守る。

```bash
# 16 MiB の Secure Heap（最小ブロック 4 KiB）
node --secure-heap=16777216 --secure-heap-min=4096 app.mjs
```

Linux/macOS 専用。枯渇すると OpenSSL API がエラーを返す。

## Policy & Integrity Manifest — Require/Import をハッシュ検証

Policy 機能は、モジュールの完全性を検証し、許可されたモジュールのみをロードする仕組みです。
サプライチェーン攻撃や改ざんされた依存関係から保護します。

### Policy ファイルの生成

```bash
# 既存プロジェクトから policy.json を自動生成
node --experimental-policy=policy.json \
     --policy-integrity=auto \
     --trace-deprecation \
     app/server.js
```

### `policy.json` の構造

```json
{
  "onerror": "exit", // ポリシー違反時の動作: "exit" | "log" | "throw"
  "scopes": {
    "file:": {
      "cascade": true, // 子スコープへカスケード
      "integrity": true // 整合性チェックを有効化
    }
  },
  "resources": {
    "./app/server.js": {
      "integrity": "sha256-iuGZ6SFVFpMuHUcJciQTIKpIyaQVigMZlvg9Lx66HV8=",
      "dependencies": {
        "./router": "./app/router.js",
        "express": true // npm パッケージを許可
      }
    },
    "./app/router.js": {
      "integrity": "sha256-FKN2XmqPRcpjqX3jfKdRTnAIXyFqdc2VJKZjxLjwdkI="
    }
  }
}
```

### 実行時の検証

```bash
# ポリシーファイル自体の整合性も検証
node --experimental-policy=policy.json \
     --policy-integrity=sha256-X0pnXwAgx7mVHQ2J8fKqgyj8hYjk04cDWAlfqPTK/c4= \
     app/server.js
```

### 主な利点

- **改ざん検知**: ファイルが変更されると即座にエラー
- **依存関係の制限**: 許可されていないモジュールのロードを防止
- **ランタイム保護**: require/import 時にリアルタイム検証

未許可のパス・改ざんされたファイルは即例外となり、攻撃を未然に防ぎます。

## --max-http-header-size — HTTP ヘッダーサイズ制限

HTTP ヘッダーのサイズを制限し、Header Bomb 攻撃（CWE-400）を防ぎます。

```bash
# デフォルト: 16384 バイト (16 KiB)
# 本番環境では 8192 バイト推奨
node --max-http-header-size=8192 server.mjs
```

### 効果

- **DoS 防止**: 巨大ヘッダーによるメモリ枯渇を防止
- **パフォーマンス向上**: ヘッダー解析の高速化
- **攻撃面の削減**: Header Injection の余地を制限

### 設定の目安

- **API サーバー**: 4096〜8192 バイト
- **Web アプリ**: 8192〜16384 バイト
- **プロキシ/CDN 経由**: CDN の制限値に合わせる

## CI に組み込む推奨セット

```bash
NODE_OPTIONS="\
  --disallow-code-generation-from-strings \
  --frozen-intrinsics \
  --disable-proto=throw \
  --permission \
  --secure-heap=16777216 --secure-heap-min=4096" \
  npm test
```

---

## 実運用でのセキュリティ設定

### プロダクション推奨設定

```bash
# 本番環境での包括的なセキュリティ設定
NODE_OPTIONS="\
  --disallow-code-generation-from-strings \
  --frozen-intrinsics \
  --disable-proto=throw \
  --permission \
  --allow-fs-read=/app,/etc/ssl \
  --allow-fs-write=/tmp,/var/log \
  --secure-heap=16777216 \
  --secure-heap-min=4096 \
  --max-http-header-size=8192" \
npm start
```

### 段階的導入戦略

**フェーズ1: 監視とログ収集**

```bash
# 警告のみ、本番影響なし
NODE_OPTIONS="--trace-warnings --trace-deprecation" npm start
```

**フェーズ2: 非破壊的なセキュリティ強化**

```bash
NODE_OPTIONS="--secure-heap=16777216 --max-http-header-size=8192" npm start
```

**フェーズ3: 段階的な制限導入**

```bash
# まず eval 禁止
NODE_OPTIONS="--disallow-code-generation-from-strings" npm start

# 次にプロトタイプ保護
NODE_OPTIONS="--disallow-code-generation-from-strings --frozen-intrinsics" npm start
```

**フェーズ4: 完全なセキュリティ強化**

```bash
# 全ての保護機能を有効化
NODE_OPTIONS="<上記の本番設定>" npm start
```

### パフォーマンス監視

```js
// パフォーマンス影響の測定
const { performance } = require("perf_hooks");

const startTime = performance.now();
// アプリケーション処理
const endTime = performance.now();

console.log("Security overhead:", endTime - startTime, "ms");
console.log("Memory usage:", process.memoryUsage());
```

---

## セキュリティ監査とログ

### セキュリティイベントの監視

```js
// セキュリティ関連の警告をキャッチ
process.on("warning", (warning) => {
  if (
    warning.name === "DeprecationWarning" ||
    warning.name === "SecurityWarning"
  ) {
    console.error("Security Warning:", warning.message);
    // ログシステムに送信
    securityLogger.warn(warning);
  }
});

// Permission Model 違反のキャッチ
process.on("uncaughtException", (error) => {
  if (error.code === "ERR_PERMISSION_DENIED") {
    console.error("Permission denied:", error.message);
    // セキュリティアラート送信
    alertSystem.send("Permission violation detected");
  }
});
```

### ログ設定例

```js
const winston = require("winston");

const securityLogger = winston.createLogger({
  level: "info",
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json(),
  ),
  transports: [
    new winston.transports.File({
      filename: "/var/log/security.log",
      level: "warn",
    }),
    new winston.transports.Console({
      format: winston.format.simple(),
    }),
  ],
});

// セキュリティイベントのログ
securityLogger.warn("Eval attempt blocked", {
  request: req.url,
  userAgent: req.headers["user-agent"],
  timestamp: new Date().toISOString(),
});
```

### アラート設定

```js
// 重要なセキュリティイベントでアラート
const alertThresholds = {
  permissionDenied: 5, // 5分間に5回でアラート
  evalBlocked: 3, // 3分間に3回でアラート
  prototypePollution: 1, // 即座にアラート
};

function checkSecurityThreshold(event, count) {
  if (count >= alertThresholds[event]) {
    // Slack/Email/PagerDuty などに送信
    alertSystem.send({
      severity: "HIGH",
      event: event,
      count: count,
      timestamp: Date.now(),
    });
  }
}
```

---

## 開発者向けのセキュリティガイドライン

### コードレビューでのチェックポイント

**1. 動的コード実行の確認**

```js
// ❌ 危険なパターン
eval(userInput);
new Function(template);
vm.runInThisContext(code);

// ✅ 安全なパターン
const validator = require("ajv");
const template = require("handlebars").compile(templateString);
```

**2. オブジェクトマージの安全性**

```js
// ❌ 危険なパターン
Object.assign(target, userInput);
lodash.merge(target, userInput);

// ✅ 安全なパターン
const sanitized = sanitizeInput(userInput);
Object.assign(target, sanitized);
```

**3. ファイルアクセスの制限**

```js
// ❌ 危険なパターン
fs.readFile(userPath);
require(userModule);

// ✅ 安全なパターン
const allowedPaths = ["/app/public", "/app/uploads"];
if (allowedPaths.some((path) => userPath.startsWith(path))) {
  fs.readFile(userPath);
}
```

### セキュリティテストの自動化

```js
// security.test.js
const { spawn } = require("child_process");

describe("Security Configuration", () => {
  test("should block eval attempts", async () => {
    const result = await runWithSecurity(`
      try {
        eval('console.log("hacked")');
      } catch (e) {
        console.log('blocked');
      }
    `);
    expect(result.stdout).toContain("blocked");
  });

  test("should prevent prototype pollution", async () => {
    const result = await runWithSecurity(`
      try {
        const obj = {};
        obj.__proto__.polluted = true;
      } catch (e) {
        console.log('protected');
      }
    `);
    expect(result.stdout).toContain("protected");
  });
});

function runWithSecurity(code) {
  return new Promise((resolve) => {
    const child = spawn("node", [
      "--disallow-code-generation-from-strings",
      "--disable-proto=throw",
      "-e",
      code,
    ]);

    let stdout = "";
    child.stdout.on("data", (data) => (stdout += data));
    child.on("close", () => resolve({ stdout }));
  });
}
```

### 依存関係のセキュリティ管理

```bash
# package.json に audit スクリプトを追加
{
  "scripts": {
    "audit": "npm audit --audit-level=moderate",
    "audit-fix": "npm audit fix",
    "security-test": "jest security.test.js"
  }
}

# CI でのセキュリティチェック
npm run audit
npm run security-test
```

---

## トラブルシューティング

### よくあるセキュリティ設定エラー

**1. 動的コード生成エラー**

```
Error: Code generation from strings disallowed for this context
```

**解決策**：

- テンプレートエンジンを事前コンパイル版に変更
- `--disallow-code-generation-from-strings` を一時的に削除してテスト
- 依存関係で eval を使用するライブラリを特定

**2. Permission Model エラー**

```
Error: Access to this API has been restricted
```

**解決策**：

```bash
# デバッグモードで詳細確認
NODE_OPTIONS="--permission --trace-warnings" node app.js

# 必要な権限を段階的に追加
--allow-fs-read=/path/to/required/directory
```

**3. Secure Heap 枯渇**

```
Error: secure heap allocation failed
```

**解決策**：

```bash
# ヒープサイズを増加
--secure-heap=33554432  # 32 MiB に増加

# 使用状況の監視
console.log(process.memoryUsage().secureHeap);
```

### デバッグ方法とログ解析

**詳細なデバッグ情報**：

```bash
# 全ての警告とトレースを表示
NODE_OPTIONS="--trace-warnings --trace-deprecation --trace-sync-io" node app.js

# セキュリティ関連のみフィルタ
node app.js 2>&1 | grep -E "(Security|Permission|Eval|Prototype)"
```

**ログ解析例**：

```bash
# セキュリティイベントの統計
grep "Permission denied" /var/log/security.log | wc -l
grep "Eval blocked" /var/log/security.log | tail -10

# 攻撃パターンの分析
awk '/Permission denied/ {print $5}' /var/log/security.log | sort | uniq -c
```

### パフォーマンス問題の対処法

**メモリ使用量の最適化**：

```js
// セキュアヒープの使用状況監視
setInterval(() => {
  const usage = process.memoryUsage();
  if (usage.secureHeap / (16 * 1024 * 1024) > 0.8) {
    console.warn("Secure heap usage high:", usage.secureHeap);
  }
}, 60000);
```

**起動時間の改善**：

```bash
# 最小限のセキュリティ設定から開始
NODE_OPTIONS="--secure-heap=8388608" npm start

# 段階的に追加
NODE_OPTIONS="--secure-heap=8388608 --max-http-header-size=8192" npm start
```

---

## 参考リンク

- [Node.js CLI Flags](https://nodejs.org/api/cli.html)
- [Permissions API](https://nodejs.org/api/permissions.html)
- [Policy Manifest](https://nodejs.org/api/policy.html)
- [Secure Heap](https://nodejs.org/api/cli.html#--secure-heap-size)
- [Prototype Pollution (PortSwigger)](https://portswigger.net/web-security/prototype-pollution)
- [Memory Access Violation (CWE‑284)](https://nodejs.org/ja/learn/getting-started/security-best-practices#memory-access-violation-cwe-284)
- [Node.js Debugger / Inspector](https://nodejs.org/api/debugger.html)
- [OWASP Node.js Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html)
- [Node.js Security Best Practices](https://nodejs.org/en/docs/guides/security/)
- [NIST Cybersecurity Framework](https://www.nist.gov/cyberframework)
- [CWE Top 25 Most Dangerous Software Weaknesses](https://cwe.mitre.org/top25/archive/2023/2023_top25_list.html)
