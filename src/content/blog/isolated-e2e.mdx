---
layout: ../../layouts/BlogLayout.astro
title: Playwrightで実際のDBを用いてテストを並列実行し高速化する
date: 2025-07-01
description: WorkerFixtures、動的ポート割り当て、ヘルスチェックによる完全な並列化実装
image: /images/brands/playwright.png
tags: e2e,testing,node.js
---

import OG from "../../components/OG.astro";

最近は、LLMによるコード生成が日常的になっています。
それに伴って、テストはコードが正しく実行されているかを保証するために今後更に重要になっていきますが、
LLMにとっても人間にとっても実行速度というのは重要で、特にe2eは実行速度が遅い点が課題です。

さらに実際のDBを用いたテストを行う際、並列に実行した場合にはテスト全体を冪等にすることは難しく、直列実行が一般的です。(GitHub Actionsのmatrixやコンテナで隔離すれば可能)

今回は、実際のDBを用いつつ、並列に実行し、e2e全体の実行時間を大幅に短縮しつつ堅牢にする方法を考えます。

## 今回使用する技術スタック

- Next.js
- NextAuth.js
- Prisma
- PostgreSQL
- Playwright
- Testcontainers

> [!NOTE]
> 今回は、next-authの戦略はJWTを利用します

## Playwrightの問題点

[webserver](https://playwright.dev/docs/test-webserver)は、単一のサーバー起動のみしかサポートしていないため、これに依存することはできません。
Playwrightは複数のAPPを起動することを想定してないため、もちろんポートの管理などもありません。APIからのアクセスはできるものの特に利用できるものもないためここは自分たちで対応する必要があります。

## 全体の流れ

1. APP側で認証を通るようにする
2. テストするユーザーの認証を全体のテスト前に行い、`storageState`として保存し、各テストは認証をスキップする
3. 各integrationテスト実行前に、動的にPostgreSQLコンテナとAPPを起動する
4. 各テストは、`afterEach`でDBのデータをリセットする
5. 各integrationはテストが終了次第、DBの破棄とAPPの終了を行う

## APP側で認証を通るようにする

Googleなどの認証をe2eで突破するのは大変なので、あまりやりたくないですが、プロダクトコード内で偽装します。
`NEXTAUTH_TEST_MODE === "true"`のときに、JWTのエンコード/デコード処理を上書きします。

<OG url="https://zenn.dev/moozaru/articles/e35ce8e47ac805" />

<br />

```ts {3-16} {25}
import type { NextAuthConfig } from "next-auth";

export const configForTest = {
  jwt: {
    encode: async ({ token }) => {
      return btoa(JSON.stringify(token));
    },
    decode: async ({ token }) => {
      if (!token) {
        return {};
      }

      return JSON.parse(atob(token));
    },
  },
} satisfies Omit<NextAuthConfig, "providers">;

export const config = {
  providers: [],
  callbacks: {
    session: ({ session }) => {
      return session;
    },
  },
  ...(process.env.NEXTAUTH_TEST_MODE === "true" ? configForTest : {}),
} satisfies NextAuthConfig;
```

## ユーザーの認証状態を事前に作成する

毎回のテストでログイン処理を実行することは、実行時間の観点から非効率的です。
Playwrightの公式ドキュメントにもあるように、テストで使用するすべてのユーザーの認証状態を事前に`storageState`として保存しておくことで、各テストケースではすでにログイン済みの状態から開始できるようになります。
これを実行すると、`e2e/.auth`にそれぞれのアカウントの認証状態がjsonで保存されます。

<OG url="https://playwright.dev/docs/auth" />

::: code-group

```ts [e2e/dummyUsers.ts] title="ダミーユーザーの作成"
import type { User } from "next-auth";

export const user1: User = {
  id: "id1",
  name: "user1",
  email: "user1@a.com",
  image:
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAMElEQVR42u3OMQEAAAQAMDrpp4Zuyojh2RIsa7bjUQoICAgICAgICAgICAgICHwHDhv0ROEuXMGUAAAAAElFTkSuQmCC",
  role: "USER",
};
```

```ts [playwright.config.ts]
import { defineConfig, devices } from "@playwright/test";

export default defineConfig({
  testDir: "./e2e",
  fullyParallel: true, // 並列実行させる
  projects: [
    {
      name: "setup",
      testMatch: /.\/e2e\/setup\/.*.ts/,
    },
    {
      name: "chrome",
      use: {
        ...devices["Desktop Chrome"],
      },
      dependencies: ["setup"], // setupの後に実行
    },
  ],
});
```

```ts [e2e/helpers/users.ts]
import type { BrowserContext, TestType } from "@playwright/test";
import type { User } from "next-auth";
import type { JWT } from "next-auth/jwt";

export async function createUserAuthState(context: BrowserContext, jwt: JWT) {
  // Next.jsのNextAuthで使用されるCookieを手動で設定
  // 実際のログインプロセスを省略し、認証済み状態を直接作成
  await context.addCookies([
    {
      name: "next-auth.session-token",
      value: btoa(
        JSON.stringify({
          ...jwt,
          sub: jwt.user.id,
        }),
      ),
      domain: "localhost",
      path: "/",
      httpOnly: true,
      sameSite: "Lax",
      expires: Math.round((Date.now() + 60 * 60 * 24 * 1000 * 7) / 1000),
    },
  ]);

  // ブラウザの認証状態をファイルに保存し、各テストでこのファイルを読み込むことにより認証済み状態を復元
  await context.storageState({
    path: getStorageStatePath(jwt.user.id ?? ""),
  });
}
```

```ts [e2e/setup/auth.ts]
import { test as setup } from "@playwright/test";
import { user1 } from "../dummyUsers";
import { createUserAuthState } from "../helpers/users";

setup("Create user1 auth", async ({ context }) => {
  await createUserAuthState(context, {
    user: user1,
  });
});
```

:::

## ワーカーごとの独立した環境を構築する

複数のDBとAPPを並列に起動するための仕組みを構築します。これにより、各ワーカーが独立した環境でテストを実行できるようになります。

### 動的にDBを起動させる準備をする

Testcontainersを用いて、PostgreSQLのコンテナを動的に起動し、各ワーカーが独自のデータベースを使用できるようにします。これにより、テスト間でのデータ競合を防ぎます。

<OG url="https://testcontainers.com/" />

今回は、dockerの`compose`を利用していますが、そうでない場合は`GenericContainer`を利用してください。portを`0`にしておくことにより、空いているポートに勝手にアサインされます。

ここでは競合ポートを避ける処理と起動までの準備を行います。

::: code-group

```yaml [compose.yml]
services:
  db:
    image: postgres:17
    ports:
      - "${DATABASE_PORT:-5432}:5432" # 動的ポート対応のため、上書きできるようにしておく
    environment:
      POSTGRES_DB: testdb
      POSTGRES_USER: testuser
      POSTGRES_PASSWORD: testpass
```

```ts [tests/db.setup.ts]
import { exec } from "node:child_process";
import { promisify } from "node:util";
import { DockerComposeEnvironment, Wait } from "testcontainers";
import { Prisma, PrismaClient } from "../src/app/__generated__/prisma";
import { createDBUrl } from "../src/app/_utils/db";

const execAsync = promisify(exec);

export async function setupDB({ port }: { port: "random" | number }) {
  const container = await new DockerComposeEnvironment(".", "compose.yml")
    .withEnvironmentFile(".env.test") // テスト専用の環境変数ファイル
    .withEnvironment({
      // 0を指定することでOSが自動的に空きポートを割り当て
      DATABASE_PORT: port === "random" ? "0" : `${port}`,
    })
    .withWaitStrategy("db", Wait.forListeningPorts())
    .up(["db"]);

  const dbContainer = container.getContainer("db-1");
  const mappedPort = dbContainer.getMappedPort(5432);
  const url = createDBUrl({
    host: dbContainer.getHost(),
    port: mappedPort,
  });

  // migrate
  await execAsync(`DATABASE_URL=${url} npx prisma db push`);

  const prisma = new PrismaClient({ datasources: { db: { url } } });

  async function down() {
    await prisma.$disconnect();
    await container.down();
  }

  return {
    url,
    container,
    port: mappedPort,
    prisma,
    down,
    async [Symbol.asyncDispose]() {
      await down();
    },
  } as const;
}
```

:::

ちなみに`db.setup.ts`はvitestで並列にDBを立ち上げることもできるので、共通化しておくと便利です。

### 動的にAPPを起動する準備

データベースの隔離と同様に、各ワーカーは独自のポートでNext.jsを起動する必要があります。`baseURL`や、`dbPort`、`appPort`を実行時に環境変数で上書きし、各種ポートや向き先を変更します。
また、ポートの確率やヘルスチェックを行うためのユーティリティ関数も用意します。[get-port](https://www.npmjs.com/package/get-port)を利用してもいいです。

ここでも競合ポートを避ける処理と起動までの準備を行います。

::: code-group

```ts [e2e/helpers/setupApp.ts]
import { exec } from "node:child_process";
import { getRandomPort } from "./getRandomPort";
import { waitForHealth } from "./waitForHealth";

export async function setupApp(dbPort: number) {
  const appPort = await getRandomPort();
  const baseURL = `http://localhost:${appPort}`;
  const cp = exec(
    `NEXTAUTH_URL=${baseURL} DATABASE_PORT=${dbPort} pnpm start --port ${appPort}`,
  );
  await waitForHealth(baseURL);

  return {
    appPort,
    baseURL,
    async [Symbol.asyncDispose]() {
      if (cp.pid) {
        process.kill(cp.pid);
      }
    },
  } as const;
}
```

```ts [e2e/helpers/getRandomPort.ts]
import { createServer } from "node:http";

export async function getRandomPort() {
  return new Promise<number>((resolve) => {
    const server = createServer();

    server.listen(0, () => {
      const address = server.address();
      const port = address && typeof address === "object" ? address.port : null;

      if (port) {
        server.close();
        resolve(port);
      }
    });
  });
}
```

```ts [e2e/helpers/waitForHealth.ts]
import { setTimeout } from "node:timers/promises";

export async function waitForHealth(baseUrl: string) {
  const maxAttempts = 30;
  const interval = 100;
  const healthUrl = `${baseUrl}/api/health`;
  let attempts = 0;

  while (attempts < maxAttempts) {
    try {
      const response = await fetch(healthUrl);

      if (response.ok) {
        const data = await response.json();

        if (data.status === "ok") {
          return;
        }
      }
    } catch {}

    attempts++;
    await setTimeout(interval);
  }

  throw new Error(`Server health check failed after ${maxAttempts} attempts`);
}
```

:::

### fixturesでDBとAPPを起動する

次に、Playwrightの`fixtures`を利用して、各ワーカーごとに独立したデータベースとアプリケーションを起動する仕組みを実装します。
`worker`スコープを定義し、workerプロセスごとに起動のsetupを自動で行います。

<OG url="https://playwright.dev/docs/test-fixtures#worker-scoped-fixtures" />

::: code-group

```ts [e2e/fixtures.ts]
import { test as base } from "@playwright/test";
import type { User } from "next-auth";
import { setupDB } from "../tests/db.setup";
import { setupApp } from "./helpers/app";
import { generatePrismaClient } from "./helpers/prisma";

export type TestFixtures = {};

export type WorkerFixtures = {
  setup: Awaited<{
    prisma: Awaited<ReturnType<typeof setupDB>>["prisma"];
    appPort: number;
    baseURL: string;
    dbURL: string;
  }>;
};

export const test = base.extend<TestFixtures, WorkerFixtures>({
  setup: [
    async ({ browser }, use) => {
      await using dbSetup = await setupDB({ port: "random" });
      await using appSetup = await setupApp(dbSetup.port);
      const baseURL = appSetup.baseURL;
      const originalNewContext = browser.newContext.bind(browser);

      // 新しいbaseURLを含んだコンテキストを新たに作成
      browser.newContext = async () => {
        return originalNewContext({ baseURL });
      };

      await use({
        prisma: dbSetup.prisma,
        appPort: appSetup.appPort,
        baseURL,
        dbURL: dbSetup.url,
      });
    },
    {
      scope: "worker",
      auto: true,
    },
  ],
});
```

```ts [e2e/helpers/prisma.ts]
import { PrismaClient } from "../../src/app/__generated__/prisma";

export async function generatePrismaClient(url: string) {
  const prisma = new PrismaClient({
    datasources: {
      db: {
        url,
      },
    },
  });

  return {
    prisma,
    async [Symbol.asyncDispose]() {
      await prisma.$disconnect();
    },
  } as const;
}
```

:::

## テストユーザーを利用できるようにする

最初に作成したログイン済みユーザーをテストで利用できるように変更します。

::: code-group

```ts [e2e/fixtures.ts]
import { test as base } from "@playwright/test";
import type { User } from "next-auth";
import { setupDB, truncate } from "../tests/db.setup";
import { setupApp } from "./helpers/app";
import { generatePrismaClient } from "./helpers/prisma";
import { registerUserToDB } from "./helpers/users";

export type TestFixtures = {
  storageState: string;
  registerToDB: (user: User) => Promise<void>;
  reset: () => Promise<void>;
};

export type WorkerFixtures = {
  setup: Awaited<{
    prisma: Awaited<ReturnType<typeof setupDB>>["prisma"];
    appPort: number;
    baseURL: string;
    dbURL: string;
  }>;
};

export const test = base.extend<TestFixtures, WorkerFixtures>({
  setup: [
    async ({ browser }, use) => {
      await using dbSetup = await setupDB({ port: "random" });
      await using appSetup = await setupApp(dbSetup.port);
      const baseURL = appSetup.baseURL;

      const originalNewContext = browser.newContext.bind(browser);

      // 新しいbaseURLを含んだコンテキストを新たに作成
      browser.newContext = async () => {
        return originalNewContext({
          baseURL,
        });
      };

      await use({
        prisma: dbSetup.prisma,
        appPort: appSetup.appPort,
        baseURL,
        dbURL: dbSetup.url,
      });
    },
    {
      scope: "worker",
      auto: true,
    },
  ],
  registerToDB: async ({ reset, setup }, use) => {
    await use(async (user: User) => {
      await registerUserToDB(user, setup.dbURL);
    });
    await reset();
  },
});
```

:::

## 実際のテスト記述

実際のテストコードでは、WorkerFixturesを活用して効率的なテストを記述できます。事前に作成した認証状態とfixturesから提供されるPrismaインスタンスを組み合わせることで、簡潔で保守性の高いテストコードが実現できます。

::: code-group

```ts [並列テスト例]
import { expect } from "@playwright/test";
import { test } from "../fixtures";
import { user1 } from "../dummyUsers";

test.describe("User management", () => {
  test.afterEach(async ({ reset }) => {
    await reset(); // 軽量なリセット処理のみ
  });

  test("should create user", async ({ page, setup }) => {
    // setupはworker開始時に初期化済み
    await setup.prisma.user.create({
      data: { name: "test user", email: "test@example.com" },
    });

    await page.goto("/users"); // baseURLが設定済み
    await expect(page.getByText("test user")).toBeVisible();
  });

  test("should delete user", async ({ page, setup }) => {
    // 同じworker内なら同じsetupを共有（効率的）
    const user = await setup.prisma.user.create({
      data: { name: "to be deleted", email: "delete@example.com" },
    });

    await page.goto(`/users/${user.id}/delete`);
    await page.click('[data-testid="confirm-delete"]');
    await expect(page.getByText("User deleted")).toBeVisible();
  });
});
```

```ts [認証状態の活用]
test.describe("認証が必要な機能", () => {
  test.use({
    storageState: getStorageStatePath(user1.id), // 事前作成した認証状態
  });

  test("投稿を作成できる", async ({ page, setup }) => {
    await setup.prisma.post.create({
      data: {
        title: "テスト投稿",
        content: "テスト内容",
        authorId: user1.id,
      },
    });

    await page.goto("/posts");
    await expect(page.getByText("テスト投稿")).toBeVisible();
  });
});
```

:::

## まとめ

本記事で紹介した一連のテクニックを活用することで、実際のデータベースを使用したPlaywrightテストの完全な並列化が実現できます。開発環境と同じ構成でテストを実行できるため、本番環境により近い条件での検証が可能となり、テストの信頼性が大幅に向上します。

特に、LLMを活用した開発が増えている現在において、このような堅牢なテスト環境は品質保証の要となります。AIが生成したコードに対しても、実際のデータベースと実環境に近い条件でのE2Eテストを実行することで、高い品質を保ちながら開発速度を向上させることができます。

---

類似の内容でunit testでの実装は以下を参照

<OG url="https://hiroppy.me/blog/testcontainers-parallel-tests" />
